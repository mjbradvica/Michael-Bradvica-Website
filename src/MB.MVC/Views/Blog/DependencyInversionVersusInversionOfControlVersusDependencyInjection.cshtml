<blog-post title="Dependency Inversion vs. Inversion of Control vs. Dependency Injection">
    <h5 class="title is-5">
        Dependency Inversion
    </h5>
    <p>
        Dependency Inversion is a <em>principle</em> that comes from the set of SOLID principles of software engineering. It can be summarized by the following:
    </p>
    <ul>
        <li>Use abstractions such as an interface or base class</li>
        <li>These abstractions should not depend on details</li>
    </ul>
    <p>
        This can be realized in a number of ways:
    </p>
    <ul>
        <li>Layering your application to separate presentation, data, and business logic</li>
        <li>Having layers interact with each other via interfaces</li>
        <li>Returning abstractions from use cases instead of raw domain objects</li>
    </ul>
    <p>
        Dependency Inversion is concerned with how your application as a whole communicates among boundaries.
    </p>
    <h5 class="title is-5">
        Inversion of Control
    </h5>
    <p>
        Inversion of Control is a <em>principle</em> concerned with separating abstractions from implementations. Inversion of Control is analogous, yet distinct, from Dependency Inversion. It is implemented at the module level of your application through a number of commonly known patterns and techniques.
    </p>
    <ul>
        <li>Event-Driven Design</li>
        <li>Service Locator</li>
        <li>Factory Method and Factory Pattern</li>
        <li>Strategy Pattern</li>
        <li>Dependency Injection</li>
    </ul>
    <p>Each of these patterns is built around separating what a module wants to do and how it is performed.</p>
    <ul style="list-style-type: none">
        <li><strong>Events</strong> - Something happened, but I don't care what happens next.</li>
        <li><strong>Service Locator</strong> - I need this service, but I don't care about the implementation.</li>
        <li><strong>Factories</strong> - I need an object, but I don't care how it is created.</li>
        <li><strong>Strategy</strong> - I have an object for a business process, but I don't care about details.</li>
        <li><strong>Dependency Injection</strong> - I need these interfaces, but I don't care about their implementations.</li>
    </ul>
    <p>Most of these techniques are used at the module level such as inside of an application service or an individual object.</p>
    <h5 class="title is-5">
        Dependency Injection
    </h5>
    <p>A type of <em>technique</em>, Dependency Injection is an implementation of Inversion of Control. It is concerned with how objects should define relationships with other objects. Dependency Injection states there are three ways to give an object a dependency:</p>
    <ul>
        <li>Constructor</li>
        <li>Method</li>
        <li>Property</li>
    </ul>
    <p>Dependency Injection is one example of aggregation. Given an object <em>n</em>, all dependencies of <em>n</em> should have independent life cycles.</p>
    <h5 class="title is-5">
        Summary
    </h5>
    <p>Dependency Inversion - a principle realized at the application level; use interfaces, abstractions, and layers to separate major aspects of your application</p>
    <p>Inversion of Control - a principle realized at the module level; separate the what and the how via abstractions</p>
    <p>Dependency Injection - a technique implemented at the object level; implement relationships between objects via aggregation</p>
</blog-post>